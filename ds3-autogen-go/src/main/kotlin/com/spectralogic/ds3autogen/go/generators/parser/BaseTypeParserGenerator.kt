/*
 * ******************************************************************************
 *   Copyright 2014-2017 Spectra Logic Corporation. All Rights Reserved.
 *   Licensed under the Apache License, Version 2.0 (the "License"). You may not use
 *   this file except in compliance with the License. A copy of the License is located at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *   or in the "license" file accompanying this file.
 *   This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 *   CONDITIONS OF ANY KIND, either express or implied. See the License for the
 *   specific language governing permissions and limitations under the License.
 * ****************************************************************************
 */

package com.spectralogic.ds3autogen.go.generators.parser

import com.google.common.collect.ImmutableList
import com.google.common.collect.ImmutableMap
import com.spectralogic.ds3autogen.api.models.apispec.Ds3Element
import com.spectralogic.ds3autogen.api.models.apispec.Ds3Type
import com.spectralogic.ds3autogen.go.models.parser.*
import com.spectralogic.ds3autogen.go.utils.toGoResponseType
import com.spectralogic.ds3autogen.go.utils.toGoType
import com.spectralogic.ds3autogen.utils.ConverterUtil
import com.spectralogic.ds3autogen.utils.Ds3ElementUtil
import com.spectralogic.ds3autogen.utils.NormalizingContractNamesUtil
import com.spectralogic.ds3autogen.utils.collections.GuavaCollectors
import com.spectralogic.ds3autogen.api.models.apispec.decapitalize
import com.spectralogic.ds3autogen.api.models.apispec.capitalize

open class BaseTypeParserGenerator : TypeParserModelGenerator<TypeParser>, TypeParserGeneratorUtil {

    override fun generate(ds3Type: Ds3Type, typeMap: ImmutableMap<String, Ds3Type>): TypeParser {
        val modelName = NormalizingContractNamesUtil.removePath(ds3Type.name)
        val name = modelName + "Parser"
        val attributes = toAttributeList(ds3Type.elements, modelName)
        val childNodes = toChildNodeList(ds3Type.elements, modelName, typeMap)

        return TypeParser(name, modelName, attributes, childNodes)
    }

    /**
     * Converts all non-attribute elements within a Ds3Element list into ParsingElements, which
     * contain the Go code for parsing the Ds3Elements as child nodes.
     */
    override fun toChildNodeList(
            ds3Elements: ImmutableList<Ds3Element>?,
            typeName: String,
            typeMap: ImmutableMap<String, Ds3Type>): ImmutableList<ParseElement> {

        if (ConverterUtil.isEmpty(ds3Elements)) {
            return ImmutableList.of()
        }

        return ds3Elements!!.stream()
                .filter { ds3Element -> !Ds3ElementUtil.isAttribute(ds3Element.ds3Annotations) }
                .map { ds3Element -> toChildNode(ds3Element, typeName, typeMap) }
                .collect(GuavaCollectors.immutableList())
    }


    /**
     * Converts a Ds3Element into a ParsingElements.There are no special-cased Ds3Elements within
     * the BaseTypeParserGenerator.
     */
    override fun toChildNode(ds3Element: Ds3Element, typeName: String, typeMap: ImmutableMap<String, Ds3Type>): ParseElement {
        return toStandardChildNode(ds3Element, typeName, typeMap)
    }

    /**
     * Converts a Ds3Element into a ParsingElement, which contains the Go code for parsing the
     * specified Ds3Element as a child node. This assumes that the specified Ds3Element is not an attribute.
     */
    fun toStandardChildNode(ds3Element: Ds3Element, typeName: String, typeMap: ImmutableMap<String, Ds3Type>): ParseElement {
        val xmlTag = getXmlTagName(ds3Element)
        val modelName = typeName.decapitalize()
        val paramName = ds3Element.name.capitalize()

        // Handle case if there is an encapsulating tag around a list of elements
        if (Ds3ElementUtil.hasWrapperAnnotations(ds3Element.ds3Annotations)) {
            val encapsulatingTag = Ds3ElementUtil.getEncapsulatingTagAnnotations(ds3Element.ds3Annotations).capitalize()
            val childType = NormalizingContractNamesUtil.removePath(ds3Element.componentType)

            // Handle if the slice is common prefixes
            if (encapsulatingTag == "CommonPrefixes") {
                return ParseChildNodeAsCommonPrefix(modelName, paramName)

            }
            return ParseChildNodeAsSlice(encapsulatingTag, xmlTag, modelName, paramName, childType)
        }

        // Handle case if there is a slice to be parsed (no encapsulating tag)
        if (ds3Element.type.equals("array")) {
            val childType = toGoType(ds3Element.componentType!!)

            // Handle if the slice is a string
            if (childType == "string") {
                return ParseChildNodeAddStringToSlice(xmlTag, modelName, paramName)
            }

            // Handle if the slice is a Ds3Type defined enum
            if (isElementEnum(ds3Element.componentType!!, typeMap)) {
                return ParseChildNodeAddEnumToSlice(xmlTag, modelName, paramName, childType)
            }

            return ParseChildNodeAddToSlice(xmlTag, modelName, paramName, childType)
        }

        // Handle case if the element is an enum
        if (isElementEnum(ds3Element.type!!, typeMap)) {
            if (ds3Element.nullable) {
                return ParseChildNodeAsNullableEnum(xmlTag, modelName, paramName, toGoType(ds3Element.type!!))
            }
            return ParseChildNodeAsEnum(xmlTag, modelName, paramName)
        }

        val goType = toGoResponseType(ds3Element.type, ds3Element.componentType, ds3Element.nullable)
        val parserNamespace = getPrimitiveTypeParserNamespace(ds3Element.type!!, ds3Element.nullable)
        when (goType) {
            "bool", "*bool", "int", "*int", "int64", "*int64", "float64", "*float64"  ->
                return ParseChildNodeAsPrimitiveType(xmlTag, modelName, paramName, parserNamespace)
            "string", "*string" ->
                return ParseChildNodeAsString(xmlTag, modelName, paramName, parserNamespace)
            else -> {
                // All remaining elements represent Ds3Types
                if (goType.first() == '*') {
                    return ParseChildNodeAsNullableDs3Type(xmlTag, modelName, paramName, goType.drop(1))
                }
                return ParseChildNodeAsDs3Type(xmlTag, modelName, paramName)
            }
        }
    }

    /**
     * Determines if the specified type is an enum.
     */
    fun isElementEnum(elementType: String, typeMap: ImmutableMap<String, Ds3Type>): Boolean {
        if (ConverterUtil.isEmpty(typeMap)) {
            return false
        }
        val ds3Type = typeMap[elementType] ?: return false
        return ConverterUtil.isEnum(ds3Type)
    }

    /**
     * Converts all attributes within a Ds3Element list into ParsingElements which contain the
     * Go code for parsing the attributes.
     */
    fun toAttributeList(ds3Elements: ImmutableList<Ds3Element>?, typeName: String): ImmutableList<ParseElement> {
        if (ConverterUtil.isEmpty(ds3Elements)) {
            return ImmutableList.of()
        }
        return ds3Elements!!.stream()
                .filter { ds3Element -> Ds3ElementUtil.isAttribute(ds3Element.ds3Annotations) }
                .map { ds3Element -> toAttribute(ds3Element, typeName) }
                .collect(GuavaCollectors.immutableList())
    }

    /**
     * Converts a Ds3Element into a ParsingElement, which contains the Go code for parsing the
     * specified Ds3Element attribute. This assumes that the specified Ds3Element is an attribute.
     */
    fun toAttribute(ds3Element: Ds3Element, typeName: String): ParseElement {
        val xmlName = getXmlTagName(ds3Element)

        val goType = toGoResponseType(ds3Element.type, ds3Element.componentType, ds3Element.nullable)
        val modelName = typeName.decapitalize()
        val paramName = ds3Element.name.capitalize()

        when (goType) {
            "bool", "*bool", "int", "*int", "int64", "*int64", "float64", "*float64"  -> {
                val parserNamespace = getPrimitiveTypeParserNamespace(ds3Element.type!!, ds3Element.nullable)
                return ParseSimpleAttr(xmlName, modelName, paramName, parserNamespace)
            }
            "string" ->
                return ParseStringAttr(xmlName, modelName, paramName)
            "*string" ->
                return ParseNullableStringAttr(xmlName, modelName, paramName)
            else -> {
                if (ds3Element.nullable) {
                    return ParseNullableEnumAttr(xmlName, modelName, paramName)
                }
                return ParseEnumAttr(xmlName, modelName, paramName)
            }
        }
    }

    /**
     * Retrieves the xml tag name for the specified Ds3Element. The result is capitalized.
     */
    fun getXmlTagName(ds3Element: Ds3Element): String {
        return Ds3ElementUtil.getXmlTagName(ds3Element).capitalize()
    }

    /**
     * Gets the namespace of the required primitive type parser used to parse
     * the specified type. Assumes that the provided type is a Go primitive, or
     * a pointer to a Go primitive type.
     */
    fun getPrimitiveTypeParserNamespace(type: String, nullable: Boolean): String {
        val parserPrefix = toGoType(type).capitalize()
        if (nullable) {
            return "Nullable$parserPrefix"
        }
        return parserPrefix
    }
}